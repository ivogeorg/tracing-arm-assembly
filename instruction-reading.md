For a more succinct version of this resource, see [instruction-reading-short](instruction-reading-short.md).

| Line | Label | Instruction | Meaning |
| --- | --- | --- | --- |
| 1 |`global_count:`| |
| 2 | |        `.word   13`| This syntax indicates that the variable `global_count` is of size word (4 bytes) and has starting value 13 (in decimal). |
| 3 |`times_five:`| |
| 4 | |`sub     sp, sp, #8`| Decrement the stack pointer by 8, meaning two words (word = 4-byte memory position). This effectively creates the _stack frame_ of `times_five` on the stack, right on top of the stack frame, if any, of the function that called it, `main`. _(Note that, there is no stack frame generated for `main` because it has neither arguments, nor local variables, so it has no need for a stack frame.)_ Note that the stack pointer always points at the word which is **at** the _top_ of the stack, never an _"empty"_ word on top of the stack. |
| 5 | |`str     r0, [sp, #4]`| Store (the value of) register r0 to the stack position at stack pointer + 4 (bytes) (that is, the position right below the top of the stack). |
| 6 | |`ldr     r2, [sp, #4]`| Load into register r2 the value at the stack memory position right below the top of the stack. Note that this is what was stored in the previous instruction. It is _redundant_ but _correct_. A `mov r2, r0` would have done the job. _The redudancy comes from the generic behavior of the compiler when no compiler optimization options are used. You can see the options at the line right next to the compiler version used, at the top right of the [Compiler Explorer](https://github.com/ivogeorg/tracing-arm-assembly/blob/master/images/compiler-explorer.png) window._ |
| 7 | |`movs    r3, r2`| Copy the value of register r2 to register r3. Because there is an `s` at the end of the the `mov`, the instruction may modify the **N (negative)** and **Z (zero)** flags depending on the result of the instruction. The result of the instruction here is the value that is being copied, and so the `movs` instruction will set the **N** and **Z** flags according to this value. In this case, this information, though generated, is not used. |
| 8 | |`lsls    r3, r3, #2`| Shift the value of r3 left two positions, effectively multiplying the value by 4. The `s` at the end means that this instruction may set any of the 4 status flags **NZCV**. _Note that a shift left may result in a carry and an overflow._ |
| 9 | |`adds    r3, r3, r2`| Add the value of r2 to r3 (and write the result to r3). This effectilvey completes the multiplication by 5 of the `times_five` function. So, `5 * a = a + a<<2`. Note the `s`.|
| 10 | |`movs    r0, r3`| Copy the value of r3 to r0. Register r0 is frequently used to pass arguments from a caller function (here, `main`) to the called function (here, `times_five`), and then to "return" the result of the called function to the caller function. Note the `s`.|
| 11 | |`add     sp, sp, #8`| Increment the stack pointer by 2 words (that is, 8 bytes), effectively removing the stack frame for `times_five` from the stack. |
| 12 | |`bx      lr`| Branch unconditionally by exchanging the link register `lr` and the program counter `pc`. Note that the branch to `times_five` from `main` is `bl`, which means _branch with link_, which in turn means branch to this address and store the address of the next instruction (the instruction right below the branch) in the link register `lr`. |
| 13 |`main:`| |
| 14 | |`push    {r4, lr}`| Push registers r4 and `lr` onto the stack. _(This is done to save their values which might be needed by the caller of this program, which is some other program. When this program terminates, it will restore the values so the caller program can resume its operation.)_ The registers are stored in order, with the lowest registers at the lowest addresses. _Note that `push` also decrements the stack pointer by two words_.|
| 15 | |`ldr     r3, .L6`| Load the address that is generated (aka corresponds to) the label `.L6` into register r3. This is the address of the memory where the value of the global variable `global_count` is stored. The label `.L6` is automatically generated by the compiler and is assigned a particular memory address at runtime. _Note that this memory location is not in the address space (just a fancy word for a range of memory addresses) for the stack, but the one for data. There are various named address segments/spaces in computing memory management, and "stack" is just one of them._ |
| 16 | |`ldr     r3, [r3]`| Treat the value of r3 as an address (we just wrote an address there) and load the value at that address back into r3. This is essentially, in the parlance of the C/C++ programming languages, the _dereferencing of a pointer_.|
| 17 | |`cmp     r3, #13`| Compare the value of r3 with 13 (in decimal). The syntax `#13` represents an _immediate value_ in assembly, which is essentially just a numerical constant. In the parlance of the C/C++ programming languages, this is called a _[literal](https://www.tutorialspoint.com/cprogramming/c_constants.htm)_. _Note that the `cmp` instruction is a comparison instruction and therefore can set the values of the **NZCV** flags. No `s` needs to be appended to (the opcode of) comparison instructions. They set the flags by default._ The `cmp` instruction is actually a subtraction - it subtracts 13 from (the value of) r3, without changing the value of r3 - and sets the **NZCV** flags based on the result. In this case, the result is _zero_ so the **Z** flag is set to 1. |
| 18 | |`bgt     .L4`| This is a branch `b` with the _greater than_ `gt` condition. This means that a branch to the address generated for the label `.L4` will be executed if the **NZCV** flags encode the _greater than_ condition. The flag values that encode _greater than_ are Z = 0 and N = V. So, the primary function of these flags is to enable [conditional execution](http://infocenter.arm.com/help/index.jsp?topic=/com.arm.doc.dui0497a/BABEHFEF.html), including `if`, `else if`, and `switch` statements, and `for` and `while` loops. What generated the last two instructions? The `if (global_count <= 13)` statement in the C program. If the value of `global_count` is less than or equal to 13 (in decimal), the body of the `if` statement will be executed (calling the function `times_five`); otherwise, execution will hop over the body of the `if` statement and execute the code that follows it. The latter is what the `bgt .L4` instruction encodes. In our case, we go into the body and call the function. |
| 19 | |`ldr     r3, .L6`| Same as line 15. Redundant code. |
| 20 | |`ldr     r3, [r3]`| Same as line 16. Redundant code. |
| 21 | |`movs    r0, r3`| Copy the value of r3 to r0. See the notes on r0 on line 10. See the notes on the `s` suffix on (the opcode of) the instruction on line 9. |
| 22 | |`bl      times_five`| Branch with link to the address generated for the label `times_five`. See the notes on branch with link and branch with exchange on line 12. |
| 23 | |`movs    r2, r0`| Copy the value of r0 to r2. See the notes on r0 on line 10. Note the `s`. See the notes on the `s` suffix on line 9. |
| 24 | |`ldr     r3, .L6`| Same as line 19. Redundant code. |
| 25 | |`str     r2, [r3]`| Store the value of r2 at the address contained in r3. This is the original address of the global variable `global_count`. This is writing the modified data to that location. |
| 26 |`.L4:`| | Dummy label (and, at runtime, address) generated for the implicit `else` statement of the `if (global_count <= 13)` statement. |
| 27 | |`movs    r3, #0`| Write the _immediate value_ 0 in r3. Note the `s`. This will set the **Z** flag. |
| 28 | |`movs    r0, r3`| Copy the value of r3 to r0. See the notes on r0 on line 10. Note the `s`.|
| 29 | |`pop     {r4, pc}`| Since `main` has no stack frame to clean up (see the notes on line 4), pop the two words left at the top of the stack, writing them to the target registers r4 and `pc` in the same order as they were written by `push`. Note that this writes the pre-`main` value of `lr` (that is, the value set by the caller of the program) to `pc`, so execution will resume at the value of `lr`. Note also that `pop` increments the stack pointer `sp`. |
| 30 |`.L6:`| |
| 31 | |`.word   global_count`| This syntax indicates that there is a variable `global_count` and its value is stored at the address that will be generated for the label `.L6`. |
